<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Truck Master</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            touch-action: none;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
        }

        /* HUD Overlay */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        #timer {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 28px;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-weight: bold;
        }

        #level-indicator {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            color: #ffd700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-weight: bold;
        }

        /* Mini Map */
        #minimap-container {
            position: absolute;
            top: 20px;
            right: 20px;
            pointer-events: auto;
            cursor: pointer;
        }

        #minimap {
            width: 150px;
            height: 150px;
            border: 3px solid #ffd700;
            border-radius: 10px;
            background: rgba(0,0,0,0.7);
            transition: all 0.3s ease;
        }

        #minimap.expanded {
            width: 400px;
            height: 400px;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
        }

        #minimap-close {
            display: none;
            position: absolute;
            top: -15px;
            right: -15px;
            width: 30px;
            height: 30px;
            background: #ff4444;
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 20px;
            cursor: pointer;
            z-index: 201;
        }

        #minimap.expanded + #minimap-close {
            display: block;
        }

        /* Touch Controls */
        #touch-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: auto;
        }

        .control-area {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            border: 3px solid rgba(255,255,255,0.6);
            color: white;
            font-size: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }

        .control-btn:active {
            background: rgba(255,255,255,0.5);
        }

        .steering-controls {
            flex-direction: row;
        }

        /* Menu Screens */
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 300;
        }

        .menu-screen.hidden {
            display: none;
        }

        #start-screen h1 {
            font-size: 64px;
            color: #ffd700;
            text-shadow: 4px 4px 8px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }

        #start-screen .subtitle {
            font-size: 24px;
            color: #aaa;
            margin-bottom: 40px;
        }

        .menu-btn {
            padding: 20px 60px;
            font-size: 28px;
            background: linear-gradient(135deg, #ffd700, #ff8c00);
            border: none;
            border-radius: 15px;
            color: #1a1a2e;
            font-weight: bold;
            cursor: pointer;
            margin: 10px;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .menu-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(255,215,0,0.4);
        }

        /* Leaderboard */
        #leaderboard {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            border: 2px solid #ffd700;
            border-radius: 10px;
            padding: 20px;
            min-width: 300px;
            max-height: 300px;
            overflow-y: auto;
        }

        #leaderboard h3 {
            color: #ffd700;
            text-align: center;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            color: #fff;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.2);
        }

        .leaderboard-entry:last-child {
            border-bottom: none;
        }

        .leaderboard-entry .rank {
            color: #ffd700;
            width: 30px;
        }

        .leaderboard-entry .name {
            flex: 1;
        }

        .leaderboard-entry .time {
            color: #4ade80;
        }

        /* Level Complete Screen */
        #level-complete {
            background: rgba(0,0,0,0.9);
        }

        #level-complete h2 {
            font-size: 48px;
            color: #4ade80;
            margin-bottom: 20px;
        }

        #level-complete .time-display {
            font-size: 36px;
            color: #ffd700;
            margin-bottom: 30px;
        }

        /* Ezra Message */
        #ezra-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #ffd700, #ff8c00);
            padding: 30px 50px;
            border-radius: 20px;
            font-size: 32px;
            font-weight: bold;
            color: #1a1a2e;
            text-align: center;
            z-index: 250;
            animation: ezraPop 0.5s ease-out;
            pointer-events: none;
            display: none;
        }

        @keyframes ezraPop {
            0% { transform: translate(-50%, -50%) scale(0); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        /* Truck Dashboard */
        #dashboard {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
        }

        #speedometer {
            width: 120px;
            height: 60px;
            background: rgba(0,0,0,0.7);
            border: 3px solid #333;
            border-radius: 60px 60px 0 0;
            position: relative;
            overflow: hidden;
        }

        #speed-needle {
            position: absolute;
            bottom: 5px;
            left: 50%;
            width: 4px;
            height: 50px;
            background: linear-gradient(to top, #ff4444, #ff0000);
            transform-origin: bottom center;
            transform: translateX(-50%) rotate(-60deg);
            transition: transform 0.1s;
        }

        #speed-value {
            position: absolute;
            bottom: 5px;
            width: 100%;
            text-align: center;
            color: #4ade80;
            font-size: 14px;
            font-weight: bold;
        }

        /* Instructions */
        #instructions {
            position: absolute;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            color: #aaa;
            font-size: 14px;
            text-align: center;
        }

        /* Unstable Plank Warning */
        #unstable-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 100, 0, 0.9);
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            color: white;
            display: none;
            z-index: 150;
            animation: shake 0.3s infinite;
        }

        @keyframes shake {
            0%, 100% { transform: translate(-50%, -50%) rotate(-1deg); }
            50% { transform: translate(-50%, -50%) rotate(1deg); }
        }

        /* Name Input */
        #name-input-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        #player-name {
            padding: 15px 30px;
            font-size: 24px;
            border: 3px solid #ffd700;
            border-radius: 10px;
            background: rgba(255,255,255,0.1);
            color: white;
            text-align: center;
            width: 250px;
        }

        #player-name::placeholder {
            color: rgba(255,255,255,0.5);
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Start Screen -->
        <div id="start-screen" class="menu-screen">
            <h1>TRUCK MASTER</h1>
            <p class="subtitle">Navigate the forest maze!</p>
            <div id="name-input-container">
                <input type="text" id="player-name" placeholder="Enter your name" maxlength="15">
                <button class="menu-btn" id="start-btn">START GAME</button>
                <button class="menu-btn" id="leaderboard-btn" style="background: linear-gradient(135deg, #4ade80, #22c55e);">LEADERBOARD</button>
            </div>
            <div id="instructions">
                <p>Desktop: WASD or Arrow Keys to drive</p>
                <p>Mobile: Use on-screen controls</p>
            </div>
        </div>

        <!-- Level Complete Screen -->
        <div id="level-complete" class="menu-screen hidden">
            <h2 id="complete-title">Level Complete!</h2>
            <p class="time-display" id="complete-time">Time: 0:00</p>
            <button class="menu-btn" id="next-level-btn">Next Level</button>
        </div>

        <!-- Game Complete Screen -->
        <div id="game-complete" class="menu-screen hidden">
            <h2 style="color: #ffd700; font-size: 56px;">CONGRATULATIONS!</h2>
            <p style="color: #4ade80; font-size: 32px; margin: 20px 0;" id="final-time">Total Time: 0:00</p>
            <p style="color: #fff; font-size: 24px; margin-bottom: 30px;">You've mastered all three levels!</p>
            <button class="menu-btn" id="play-again-btn">Play Again</button>
            <button class="menu-btn" id="view-leaderboard-btn" style="background: linear-gradient(135deg, #4ade80, #22c55e);">View Leaderboard</button>
        </div>

        <!-- Leaderboard Screen -->
        <div id="leaderboard-screen" class="menu-screen hidden">
            <h2 style="color: #ffd700; font-size: 48px; margin-bottom: 30px;">LEADERBOARD</h2>
            <div id="leaderboard">
                <h3>Top Times</h3>
                <div id="leaderboard-list"></div>
            </div>
            <button class="menu-btn" id="back-btn" style="margin-top: 30px;">Back to Menu</button>
        </div>

        <!-- HUD -->
        <div id="hud" class="hidden">
            <div id="timer">0:00.0</div>
            <div id="level-indicator">Level 1</div>

            <div id="minimap-container">
                <canvas id="minimap"></canvas>
                <button id="minimap-close">&times;</button>
            </div>

            <div id="dashboard">
                <div id="speedometer">
                    <div id="speed-needle"></div>
                    <div id="speed-value">0 MPH</div>
                </div>
            </div>

            <div id="touch-controls">
                <div class="control-area">
                    <button class="control-btn" id="btn-forward">&#9650;</button>
                    <button class="control-btn" id="btn-backward">&#9660;</button>
                </div>
                <div class="control-area steering-controls">
                    <button class="control-btn" id="btn-left">&#9664;</button>
                    <button class="control-btn" id="btn-right">&#9654;</button>
                </div>
            </div>
        </div>

        <div id="unstable-warning">‚ö†Ô∏è UNSTABLE PLANK!</div>
        <div id="ezra-message"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game State
        const gameState = {
            currentLevel: 1,
            totalLevels: 3,
            startTime: 0,
            levelTimes: [],
            totalTime: 0,
            playerName: '',
            isPlaying: false,
            isPaused: false
        };

        // Controls State
        const controls = {
            forward: false,
            backward: false,
            left: false,
            right: false
        };

        // Truck State
        const truck = {
            position: { x: 0, z: 0 },
            rotation: 0,
            speed: 0,
            maxSpeed: 0.15,
            acceleration: 0.005,
            deceleration: 0.003,
            turnSpeed: 0.03,
            mesh: null,
            onUnstable: false
        };

        // Maze configurations for each level
        const mazeConfigs = [
            // Level 1 - Simple maze (7x7)
            {
                size: 7,
                maze: [
                    [1,1,1,1,1,1,1],
                    [1,0,0,0,1,0,1],
                    [1,0,1,0,0,0,1],
                    [1,0,1,1,1,0,1],
                    [1,0,0,0,0,0,1],
                    [1,1,1,0,1,0,1],
                    [1,1,1,1,1,1,1]
                ],
                start: { x: 1, z: 1 },
                end: { x: 5, z: 5 },
                unstablePlanks: [[2, 2], [4, 3]]
            },
            // Level 2 - Medium maze (9x9) - Purple trees
            {
                size: 9,
                maze: [
                    [1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,1,0,0,0,1],
                    [1,0,1,0,1,0,1,0,1],
                    [1,0,1,0,0,0,1,0,1],
                    [1,0,1,1,1,0,1,0,1],
                    [1,0,0,0,0,0,1,0,1],
                    [1,1,1,0,1,1,1,0,1],
                    [1,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1]
                ],
                start: { x: 1, z: 1 },
                end: { x: 7, z: 7 },
                unstablePlanks: [[3, 3], [5, 5], [2, 6]]
            },
            // Level 3 - Complex maze (11x11) - Orange planks
            {
                size: 11,
                maze: [
                    [1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,0,0,1,0,0,0,1],
                    [1,0,1,1,1,0,1,0,1,0,1],
                    [1,0,1,0,0,0,0,0,1,0,1],
                    [1,0,1,0,1,1,1,0,1,0,1],
                    [1,0,0,0,1,0,0,0,0,0,1],
                    [1,1,1,0,1,0,1,1,1,0,1],
                    [1,0,0,0,0,0,1,0,0,0,1],
                    [1,0,1,1,1,0,1,0,1,1,1],
                    [1,0,0,0,0,0,0,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1]
                ],
                start: { x: 1, z: 1 },
                end: { x: 9, z: 9 },
                unstablePlanks: [[3, 3], [5, 5], [7, 3], [3, 7], [6, 8]]
            }
        ];

        // Three.js variables
        let scene, camera, renderer;
        let trees = [];
        let planks = [];
        let goalMarker;
        let minimapCanvas, minimapCtx;

        // DOM Elements
        const startScreen = document.getElementById('start-screen');
        const levelComplete = document.getElementById('level-complete');
        const gameComplete = document.getElementById('game-complete');
        const leaderboardScreen = document.getElementById('leaderboard-screen');
        const hud = document.getElementById('hud');
        const timerDisplay = document.getElementById('timer');
        const levelIndicator = document.getElementById('level-indicator');
        const unstableWarning = document.getElementById('unstable-warning');
        const ezraMessage = document.getElementById('ezra-message');
        const speedNeedle = document.getElementById('speed-needle');
        const speedValue = document.getElementById('speed-value');

        // Initialize Three.js
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 10, 50);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.y = 1.5;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').insertBefore(renderer.domElement, document.getElementById('start-screen'));

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);

            // Initialize minimap
            minimapCanvas = document.getElementById('minimap');
            minimapCtx = minimapCanvas.getContext('2d');

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Create armored truck
        function createTruck() {
            const truckGroup = new THREE.Group();

            // Main body
            const bodyGeometry = new THREE.BoxGeometry(1.2, 0.8, 2);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x2d2d2d,
                metalness: 0.7,
                roughness: 0.3
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            truckGroup.add(body);

            // Cabin
            const cabinGeometry = new THREE.BoxGeometry(1, 0.6, 0.8);
            const cabinMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                metalness: 0.8,
                roughness: 0.2
            });
            const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
            cabin.position.set(0, 0.9, -0.5);
            cabin.castShadow = true;
            truckGroup.add(cabin);

            // Windshield
            const windshieldGeometry = new THREE.PlaneGeometry(0.8, 0.4);
            const windshieldMaterial = new THREE.MeshStandardMaterial({
                color: 0x334455,
                metalness: 0.9,
                roughness: 0.1,
                transparent: true,
                opacity: 0.7
            });
            const windshield = new THREE.Mesh(windshieldGeometry, windshieldMaterial);
            windshield.position.set(0, 1, -0.1);
            windshield.rotation.x = -0.2;
            truckGroup.add(windshield);

            // Armor plates
            const armorGeometry = new THREE.BoxGeometry(1.3, 0.1, 2.1);
            const armorMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444,
                metalness: 0.8,
                roughness: 0.4
            });
            const armorTop = new THREE.Mesh(armorGeometry, armorMaterial);
            armorTop.position.y = 0.95;
            armorTop.castShadow = true;
            truckGroup.add(armorTop);

            // Wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.2, 16);
            const wheelMaterial = new THREE.MeshStandardMaterial({
                color: 0x111111,
                metalness: 0.3,
                roughness: 0.8
            });

            const wheelPositions = [
                { x: -0.7, z: -0.6 },
                { x: 0.7, z: -0.6 },
                { x: -0.7, z: 0.6 },
                { x: 0.7, z: 0.6 }
            ];

            wheelPositions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheel.rotation.z = Math.PI / 2;
                wheel.position.set(pos.x, 0.25, pos.z);
                wheel.castShadow = true;
                truckGroup.add(wheel);
            });

            // Headlights
            const headlightGeometry = new THREE.CircleGeometry(0.1, 16);
            const headlightMaterial = new THREE.MeshBasicMaterial({ color: 0xffffcc });
            [-0.4, 0.4].forEach(x => {
                const headlight = new THREE.Mesh(headlightGeometry, headlightMaterial);
                headlight.position.set(x, 0.6, -1.01);
                truckGroup.add(headlight);
            });

            truck.mesh = truckGroup;
            scene.add(truckGroup);
        }

        // Create tree
        function createTree(x, z, level) {
            const treeGroup = new THREE.Group();

            // Trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.15, 0.2, 1.5, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a3728,
                roughness: 0.9
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 0.75;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            // Foliage color based on level
            let foliageColor = 0x228B22; // Default green
            if (level === 2) {
                foliageColor = 0x9932CC; // Purple for level 2
            }

            // Foliage layers
            const foliageGeometry1 = new THREE.ConeGeometry(0.8, 1.5, 8);
            const foliageGeometry2 = new THREE.ConeGeometry(0.6, 1.2, 8);
            const foliageGeometry3 = new THREE.ConeGeometry(0.4, 1, 8);
            const foliageMaterial = new THREE.MeshStandardMaterial({
                color: foliageColor,
                roughness: 0.8
            });

            const foliage1 = new THREE.Mesh(foliageGeometry1, foliageMaterial);
            foliage1.position.y = 1.8;
            foliage1.castShadow = true;
            treeGroup.add(foliage1);

            const foliage2 = new THREE.Mesh(foliageGeometry2, foliageMaterial);
            foliage2.position.y = 2.5;
            foliage2.castShadow = true;
            treeGroup.add(foliage2);

            const foliage3 = new THREE.Mesh(foliageGeometry3, foliageMaterial);
            foliage3.position.y = 3.1;
            foliage3.castShadow = true;
            treeGroup.add(foliage3);

            // Add some random rotation for variety
            treeGroup.rotation.y = Math.random() * Math.PI * 2;
            treeGroup.position.set(x, 0, z);

            return treeGroup;
        }

        // Create wooden plank
        function createPlank(x, z, isUnstable, level) {
            const plankGroup = new THREE.Group();

            // Plank color based on level
            let plankColor = 0x8B4513; // Default brown
            if (level === 3) {
                plankColor = 0xFF8C00; // Orange for level 3
            }

            // Create multiple planks for realistic look
            for (let i = 0; i < 4; i++) {
                const plankGeometry = new THREE.BoxGeometry(0.6, 0.08, 2.8);
                const plankMaterial = new THREE.MeshStandardMaterial({
                    color: plankColor,
                    roughness: 0.9
                });
                const plank = new THREE.Mesh(plankGeometry, plankMaterial);
                plank.position.x = (i - 1.5) * 0.7;
                plank.position.y = 0.04;
                plank.receiveShadow = true;
                plank.castShadow = true;
                plankGroup.add(plank);
            }

            // Add wood grain effect with lines
            for (let i = 0; i < 4; i++) {
                const lineGeometry = new THREE.BoxGeometry(0.55, 0.01, 2.75);
                const lineMaterial = new THREE.MeshStandardMaterial({
                    color: level === 3 ? 0xCC7000 : 0x654321
                });
                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                line.position.x = (i - 1.5) * 0.7;
                line.position.y = 0.09;
                plankGroup.add(line);
            }

            // Unstable plank indicator
            if (isUnstable) {
                const warningGeometry = new THREE.RingGeometry(0.3, 0.4, 6);
                const warningMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff4444,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.7
                });
                const warning = new THREE.Mesh(warningGeometry, warningMaterial);
                warning.rotation.x = -Math.PI / 2;
                warning.position.y = 0.1;
                plankGroup.add(warning);
                plankGroup.userData.isUnstable = true;
            }

            plankGroup.position.set(x, 0, z);
            plankGroup.userData.gridX = Math.round(x / 3);
            plankGroup.userData.gridZ = Math.round(z / 3);

            return plankGroup;
        }

        // Create goal marker
        function createGoalMarker(x, z) {
            const goalGroup = new THREE.Group();

            // Glowing pillar
            const pillarGeometry = new THREE.CylinderGeometry(0.3, 0.3, 3, 16);
            const pillarMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.5
            });
            const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
            pillar.position.y = 1.5;
            goalGroup.add(pillar);

            // Rotating ring
            const ringGeometry = new THREE.TorusGeometry(0.5, 0.1, 8, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xffd700 });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.y = 0.5;
            ring.rotation.x = Math.PI / 2;
            goalGroup.add(ring);

            // "FINISH" text indicator
            const flagGeometry = new THREE.PlaneGeometry(1.5, 0.5);
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(0, 0, 256, 64);
            ctx.fillStyle = '#000';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('FINISH', 128, 32);
            const flagTexture = new THREE.CanvasTexture(canvas);
            const flagMaterial = new THREE.MeshBasicMaterial({
                map: flagTexture,
                side: THREE.DoubleSide
            });
            const flag = new THREE.Mesh(flagGeometry, flagMaterial);
            flag.position.y = 2.5;
            goalGroup.add(flag);

            goalGroup.position.set(x, 0, z);
            goalGroup.userData.ring = ring;

            return goalGroup;
        }

        // Build level
        function buildLevel(levelNum) {
            // Clear existing objects
            trees.forEach(tree => scene.remove(tree));
            planks.forEach(plank => scene.remove(plank));
            if (goalMarker) scene.remove(goalMarker);
            trees = [];
            planks = [];

            const config = mazeConfigs[levelNum - 1];
            const cellSize = 3;

            // Create ground base
            const groundGeometry = new THREE.PlaneGeometry(config.size * cellSize + 10, config.size * cellSize + 10);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x355E3B,
                roughness: 1
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            ground.receiveShadow = true;
            scene.add(ground);
            planks.push(ground);

            // Build maze
            for (let z = 0; z < config.size; z++) {
                for (let x = 0; x < config.size; x++) {
                    const worldX = x * cellSize;
                    const worldZ = z * cellSize;

                    if (config.maze[z][x] === 1) {
                        // Wall - create trees
                        const numTrees = 2 + Math.floor(Math.random() * 2);
                        for (let i = 0; i < numTrees; i++) {
                            const offsetX = (Math.random() - 0.5) * 2;
                            const offsetZ = (Math.random() - 0.5) * 2;
                            const tree = createTree(worldX + offsetX, worldZ + offsetZ, levelNum);
                            scene.add(tree);
                            trees.push(tree);
                        }
                    } else {
                        // Path - create wooden planks
                        const isUnstable = config.unstablePlanks.some(
                            pos => pos[0] === x && pos[1] === z
                        );
                        const plank = createPlank(worldX, worldZ, isUnstable, levelNum);
                        scene.add(plank);
                        planks.push(plank);
                    }
                }
            }

            // Create goal marker
            goalMarker = createGoalMarker(
                config.end.x * cellSize,
                config.end.z * cellSize
            );
            scene.add(goalMarker);

            // Set truck position
            truck.position.x = config.start.x * cellSize;
            truck.position.z = config.start.z * cellSize;
            truck.rotation = 0;
            truck.speed = 0;

            // Update level indicator
            levelIndicator.textContent = `Level ${levelNum}`;
            if (levelNum === 2) {
                levelIndicator.style.color = '#9932CC';
            } else if (levelNum === 3) {
                levelIndicator.style.color = '#FF8C00';
            } else {
                levelIndicator.style.color = '#ffd700';
            }
        }

        // Update minimap
        function updateMinimap() {
            const config = mazeConfigs[gameState.currentLevel - 1];
            const isExpanded = minimapCanvas.classList.contains('expanded');
            const size = isExpanded ? 400 : 150;
            minimapCanvas.width = size;
            minimapCanvas.height = size;

            const cellSize = size / config.size;

            minimapCtx.fillStyle = '#1a1a1a';
            minimapCtx.fillRect(0, 0, size, size);

            // Draw maze
            for (let z = 0; z < config.size; z++) {
                for (let x = 0; x < config.size; x++) {
                    if (config.maze[z][x] === 1) {
                        // Wall
                        if (gameState.currentLevel === 2) {
                            minimapCtx.fillStyle = '#9932CC';
                        } else {
                            minimapCtx.fillStyle = '#228B22';
                        }
                    } else {
                        // Path
                        if (gameState.currentLevel === 3) {
                            minimapCtx.fillStyle = '#FF8C00';
                        } else {
                            minimapCtx.fillStyle = '#8B4513';
                        }
                    }
                    minimapCtx.fillRect(x * cellSize, z * cellSize, cellSize - 1, cellSize - 1);
                }
            }

            // Draw goal
            minimapCtx.fillStyle = '#00ff00';
            minimapCtx.beginPath();
            minimapCtx.arc(
                config.end.x * cellSize + cellSize / 2,
                config.end.z * cellSize + cellSize / 2,
                cellSize / 3,
                0,
                Math.PI * 2
            );
            minimapCtx.fill();

            // Draw player
            const playerX = (truck.position.x / 3) * cellSize + cellSize / 2;
            const playerZ = (truck.position.z / 3) * cellSize + cellSize / 2;

            minimapCtx.save();
            minimapCtx.translate(playerX, playerZ);
            minimapCtx.rotate(truck.rotation);
            minimapCtx.fillStyle = '#ff4444';
            minimapCtx.beginPath();
            minimapCtx.moveTo(0, -cellSize / 3);
            minimapCtx.lineTo(-cellSize / 4, cellSize / 3);
            minimapCtx.lineTo(cellSize / 4, cellSize / 3);
            minimapCtx.closePath();
            minimapCtx.fill();
            minimapCtx.restore();
        }

        // Check collision with walls
        function checkCollision(newX, newZ) {
            const config = mazeConfigs[gameState.currentLevel - 1];
            const cellSize = 3;
            const margin = 0.8;

            const gridX = Math.floor(newX / cellSize);
            const gridZ = Math.floor(newZ / cellSize);

            // Check bounds
            if (gridX < 0 || gridX >= config.size || gridZ < 0 || gridZ >= config.size) {
                return true;
            }

            // Check if it's a wall
            if (config.maze[gridZ][gridX] === 1) {
                return true;
            }

            // Check adjacent cells for collision
            const checkOffsets = [
                { x: margin, z: 0 },
                { x: -margin, z: 0 },
                { x: 0, z: margin },
                { x: 0, z: -margin }
            ];

            for (const offset of checkOffsets) {
                const checkX = Math.floor((newX + offset.x) / cellSize);
                const checkZ = Math.floor((newZ + offset.z) / cellSize);
                if (checkX >= 0 && checkX < config.size && checkZ >= 0 && checkZ < config.size) {
                    if (config.maze[checkZ][checkX] === 1) {
                        return true;
                    }
                }
            }

            return false;
        }

        // Check if on unstable plank
        function checkUnstablePlank() {
            const config = mazeConfigs[gameState.currentLevel - 1];
            const cellSize = 3;
            const gridX = Math.round(truck.position.x / cellSize);
            const gridZ = Math.round(truck.position.z / cellSize);

            const isOnUnstable = config.unstablePlanks.some(
                pos => pos[0] === gridX && pos[1] === gridZ
            );

            if (isOnUnstable && !truck.onUnstable) {
                truck.onUnstable = true;
                unstableWarning.style.display = 'block';
                setTimeout(() => {
                    unstableWarning.style.display = 'none';
                }, 1000);
            } else if (!isOnUnstable) {
                truck.onUnstable = false;
            }

            return isOnUnstable;
        }

        // Check if reached goal
        function checkGoal() {
            const config = mazeConfigs[gameState.currentLevel - 1];
            const cellSize = 3;
            const goalX = config.end.x * cellSize;
            const goalZ = config.end.z * cellSize;

            const distance = Math.sqrt(
                Math.pow(truck.position.x - goalX, 2) +
                Math.pow(truck.position.z - goalZ, 2)
            );

            return distance < 1.5;
        }

        // Show Ezra message
        function showEzraMessage(message) {
            ezraMessage.textContent = message;
            ezraMessage.style.display = 'block';
            setTimeout(() => {
                ezraMessage.style.display = 'none';
            }, 2500);
        }

        // Format time
        function formatTime(ms) {
            const seconds = Math.floor(ms / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            const tenths = Math.floor((ms % 1000) / 100);
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}.${tenths}`;
        }

        // Update timer
        function updateTimer() {
            if (gameState.isPlaying && !gameState.isPaused) {
                const elapsed = Date.now() - gameState.startTime;
                timerDisplay.textContent = formatTime(elapsed);
            }
        }

        // Level complete
        function levelComplete_handler() {
            gameState.isPlaying = false;
            const levelTime = Date.now() - gameState.startTime;
            gameState.levelTimes.push(levelTime);

            // Show Ezra celebration message
            const ezraMessages = [
                "Amazing driving, Ezra! üèÜ",
                "You're a TRUCK MASTER, Ezra!",
                "Ezra wins again! üéâ",
                "Unstoppable, Ezra!",
                "Ezra the Champion!"
            ];
            showEzraMessage(ezraMessages[Math.floor(Math.random() * ezraMessages.length)]);

            setTimeout(() => {
                if (gameState.currentLevel < gameState.totalLevels) {
                    document.getElementById('complete-title').textContent = `Level ${gameState.currentLevel} Complete!`;
                    document.getElementById('complete-time').textContent = `Time: ${formatTime(levelTime)}`;
                    levelComplete.classList.remove('hidden');
                    hud.classList.add('hidden');
                } else {
                    gameComplete_handler();
                }
            }, 2500);
        }

        // Game complete
        function gameComplete_handler() {
            gameState.totalTime = gameState.levelTimes.reduce((a, b) => a + b, 0);
            document.getElementById('final-time').textContent = `Total Time: ${formatTime(gameState.totalTime)}`;

            // Save to leaderboard
            saveToLeaderboard();

            gameComplete.classList.remove('hidden');
            hud.classList.add('hidden');

            // Special final message for Ezra
            setTimeout(() => {
                showEzraMessage("EZRA IS THE ULTIMATE TRUCK MASTER! üèÜüéâ");
            }, 500);
        }

        // Leaderboard functions
        function getLeaderboard() {
            const data = localStorage.getItem('truckMasterLeaderboard');
            return data ? JSON.parse(data) : [];
        }

        function saveToLeaderboard() {
            const leaderboard = getLeaderboard();
            leaderboard.push({
                name: gameState.playerName || 'Anonymous',
                time: gameState.totalTime,
                date: new Date().toISOString()
            });
            leaderboard.sort((a, b) => a.time - b.time);
            const top10 = leaderboard.slice(0, 10);
            localStorage.setItem('truckMasterLeaderboard', JSON.stringify(top10));
        }

        function displayLeaderboard() {
            const leaderboard = getLeaderboard();
            const listEl = document.getElementById('leaderboard-list');

            if (leaderboard.length === 0) {
                listEl.innerHTML = '<p style="color: #aaa; text-align: center;">No records yet!</p>';
                return;
            }

            listEl.innerHTML = leaderboard.map((entry, index) => `
                <div class="leaderboard-entry">
                    <span class="rank">#${index + 1}</span>
                    <span class="name">${entry.name}</span>
                    <span class="time">${formatTime(entry.time)}</span>
                </div>
            `).join('');
        }

        // Game loop
        function gameLoop() {
            requestAnimationFrame(gameLoop);

            if (gameState.isPlaying && !gameState.isPaused) {
                // Update truck physics
                const onUnstable = checkUnstablePlank();
                const speedMultiplier = onUnstable ? 0.4 : 1;
                const maxSpeed = truck.maxSpeed * speedMultiplier;

                if (controls.forward) {
                    truck.speed = Math.min(truck.speed + truck.acceleration, maxSpeed);
                } else if (controls.backward) {
                    truck.speed = Math.max(truck.speed - truck.acceleration, -maxSpeed * 0.5);
                } else {
                    // Deceleration
                    if (truck.speed > 0) {
                        truck.speed = Math.max(truck.speed - truck.deceleration, 0);
                    } else if (truck.speed < 0) {
                        truck.speed = Math.min(truck.speed + truck.deceleration, 0);
                    }
                }

                // Turning (only when moving)
                if (Math.abs(truck.speed) > 0.01) {
                    const turnMultiplier = truck.speed > 0 ? 1 : -1;
                    if (controls.left) {
                        truck.rotation += truck.turnSpeed * turnMultiplier;
                    }
                    if (controls.right) {
                        truck.rotation -= truck.turnSpeed * turnMultiplier;
                    }
                }

                // Calculate new position
                const newX = truck.position.x - Math.sin(truck.rotation) * truck.speed;
                const newZ = truck.position.z - Math.cos(truck.rotation) * truck.speed;

                // Check collision and update position
                if (!checkCollision(newX, newZ)) {
                    truck.position.x = newX;
                    truck.position.z = newZ;
                } else {
                    truck.speed *= -0.3; // Bounce back
                }

                // Update truck mesh
                if (truck.mesh) {
                    truck.mesh.position.x = truck.position.x;
                    truck.mesh.position.z = truck.position.z;
                    truck.mesh.rotation.y = truck.rotation;

                    // Add wobble on unstable planks
                    if (onUnstable) {
                        truck.mesh.rotation.x = Math.sin(Date.now() * 0.01) * 0.05;
                        truck.mesh.rotation.z = Math.cos(Date.now() * 0.01) * 0.05;
                    } else {
                        truck.mesh.rotation.x = 0;
                        truck.mesh.rotation.z = 0;
                    }
                }

                // Update camera (first person view)
                const cameraOffsetX = Math.sin(truck.rotation) * 0.5;
                const cameraOffsetZ = Math.cos(truck.rotation) * 0.5;
                camera.position.x = truck.position.x + cameraOffsetX;
                camera.position.z = truck.position.z + cameraOffsetZ;
                camera.position.y = 1.8;
                camera.rotation.y = truck.rotation + Math.PI;

                // Update speedometer
                const speedMPH = Math.abs(truck.speed) * 200;
                speedValue.textContent = `${Math.round(speedMPH)} MPH`;
                const needleRotation = -60 + (speedMPH / 30) * 120;
                speedNeedle.style.transform = `translateX(-50%) rotate(${needleRotation}deg)`;

                // Rotate goal marker
                if (goalMarker && goalMarker.userData.ring) {
                    goalMarker.userData.ring.rotation.z += 0.02;
                    goalMarker.position.y = Math.sin(Date.now() * 0.002) * 0.1;
                }

                // Update minimap
                updateMinimap();

                // Update timer
                updateTimer();

                // Check goal
                if (checkGoal()) {
                    levelComplete_handler();
                }
            }

            renderer.render(scene, camera);
        }

        // Input handlers
        function setupControls() {
            // Keyboard
            document.addEventListener('keydown', (e) => {
                switch (e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        controls.forward = true;
                        break;
                    case 's':
                    case 'arrowdown':
                        controls.backward = true;
                        break;
                    case 'a':
                    case 'arrowleft':
                        controls.left = true;
                        break;
                    case 'd':
                    case 'arrowright':
                        controls.right = true;
                        break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch (e.key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        controls.forward = false;
                        break;
                    case 's':
                    case 'arrowdown':
                        controls.backward = false;
                        break;
                    case 'a':
                    case 'arrowleft':
                        controls.left = false;
                        break;
                    case 'd':
                    case 'arrowright':
                        controls.right = false;
                        break;
                }
            });

            // Touch controls
            const btnForward = document.getElementById('btn-forward');
            const btnBackward = document.getElementById('btn-backward');
            const btnLeft = document.getElementById('btn-left');
            const btnRight = document.getElementById('btn-right');

            const addTouchEvents = (btn, control) => {
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    controls[control] = true;
                });
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    controls[control] = false;
                });
                btn.addEventListener('mousedown', () => controls[control] = true);
                btn.addEventListener('mouseup', () => controls[control] = false);
                btn.addEventListener('mouseleave', () => controls[control] = false);
            };

            addTouchEvents(btnForward, 'forward');
            addTouchEvents(btnBackward, 'backward');
            addTouchEvents(btnLeft, 'left');
            addTouchEvents(btnRight, 'right');

            // Minimap click to expand
            minimapCanvas.addEventListener('click', () => {
                minimapCanvas.classList.toggle('expanded');
            });

            document.getElementById('minimap-close').addEventListener('click', (e) => {
                e.stopPropagation();
                minimapCanvas.classList.remove('expanded');
            });
        }

        // Start game
        function startGame() {
            gameState.playerName = document.getElementById('player-name').value || 'Player';
            gameState.currentLevel = 1;
            gameState.levelTimes = [];
            gameState.totalTime = 0;
            gameState.isPlaying = true;
            gameState.startTime = Date.now();

            startScreen.classList.add('hidden');
            hud.classList.remove('hidden');

            buildLevel(1);
            createTruck();

            // Welcome message for Ezra
            setTimeout(() => {
                if (gameState.playerName.toLowerCase() === 'ezra') {
                    showEzraMessage("Welcome back, EZRA! Let's drive!");
                } else {
                    showEzraMessage(`Good luck, ${gameState.playerName}!`);
                }
            }, 500);
        }

        // Next level
        function nextLevel() {
            gameState.currentLevel++;
            gameState.isPlaying = true;
            gameState.startTime = Date.now();

            levelComplete.classList.add('hidden');
            hud.classList.remove('hidden');

            buildLevel(gameState.currentLevel);

            // Level-specific Ezra message
            if (gameState.currentLevel === 2) {
                setTimeout(() => showEzraMessage("Purple forest ahead, Ezra!"), 500);
            } else if (gameState.currentLevel === 3) {
                setTimeout(() => showEzraMessage("Final level! Orange planks, Ezra!"), 500);
            }
        }

        // Event listeners
        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('next-level-btn').addEventListener('click', nextLevel);
        document.getElementById('play-again-btn').addEventListener('click', () => {
            gameComplete.classList.add('hidden');
            startScreen.classList.remove('hidden');
        });
        document.getElementById('leaderboard-btn').addEventListener('click', () => {
            displayLeaderboard();
            startScreen.classList.add('hidden');
            leaderboardScreen.classList.remove('hidden');
        });
        document.getElementById('view-leaderboard-btn').addEventListener('click', () => {
            displayLeaderboard();
            gameComplete.classList.add('hidden');
            leaderboardScreen.classList.remove('hidden');
        });
        document.getElementById('back-btn').addEventListener('click', () => {
            leaderboardScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
        });

        // Initialize
        initThreeJS();
        setupControls();
        gameLoop();
    </script>
</body>
</html>
